title: ç§»åŠ¨å‘¨åˆ†äº«-ç¬¬60æœŸ
date: 2016-07-22  14:45:00
tags:
- Accelerate
categories: ç§»åŠ¨ç»„å‘¨æŠ€æœ¯åˆ†äº«

---

## åŠ é€Ÿåº“åœ¨æ•°å­¦è¿ç®—ä¸­çš„ä½¿ç”¨

> é™¤äº†åŠ å‡ä¹˜é™¤å¤–è¿˜æœ‰å¥½å¤šå¥½å¤šæ•°å­¦è¿ç®—éœ€è¦æˆ‘ä»¬å¤„ç†ï¼Œä½†æˆ‘ä»¬å¾ˆå¤šéƒ½æ²¡æœ‰ç”¨åˆ°ï¼Œæ„Ÿè§‰lowçˆ†äº†


### [Appleï¼šåŠ é€Ÿæ¡†æ¶æ–‡æ¡£](https://developer.apple.com/library/ios/documentation/Accelerate/Reference/vDSPRef/index.html#//apple_ref/doc/uid/TP40009464-CH13-12342)
> Any time you've got to make some numbers happen, it's probably worth it to consider using Accelerate

### ç¤ºä¾‹

```swift
// æ¨¡æ‹Ÿéšæœºæ•°æ®
var doubles  = (0...10000).map {_ in Double(arc4random()%10000)}

// æ±‚å’Œ
// å¸¸è§çš„åŠ æ³•æ±‚å’Œ
let reduceSum = doubles.reduce(0) { $0+$1 }
// Accelerate å°è£…
let accSum = sum(doubles)

// æ±‚æœ€å¤§å€¼ï¼ˆæœ€å°å€¼ä¹Ÿä¸€æ ·ï¼‰
let maxOfArr = max(doubles)
let maxOfArr2 = doubles.maxElement
// let maxOfArr2 = doubles.sort(>).first

// å¹³å‡å€¼,å“ˆå“ˆå¤§æ•°æ®ç»Ÿè®¡ï¼Œå¯ä»¥æµ‹è¯•å‡†ç¡®ç‡
let meanValue = mean(doubles)
let meanValue2 = doubles.reduce(0) { $0 + $1/Double(doubles.count) }
meanValue2

// å‘é‡åŠ å‡ä¹˜ç§¯
let vector1 = [2,4,5] as [Double]
let vector2 = [3,5,2] as [Double]
let sumArrs = add(vector1, y: vector2)
```

è€—æ—¶ä¸Šå¯¹æ¯”æ˜¯ä¸æ˜¯`reduceï¼Œmap`ç­‰ç³»ç»Ÿçš„é«˜é˜¶å‡½æ•°è¢«` â€œåŠ é€Ÿåº“â€ `ç§’äº†ï¼Œä½†ä½¿ç”¨ä¸Šè²Œä¼¼reduceï¼Œmapæ˜¯æ¯”è¾ƒçµæ´»çš„
```swift
let newReduceSum = (0...1000).reduce(0) { $0+$1 }
newReduceSum
```

### å…¶ä»–è®¡ç®—çš„ä¸€ç‚¹çš„åº”ç”¨
> å‡½æ•°æ··åˆç¤ºä¾‹: ä½¿ç”¨ä¸­æ–‡å˜é‡ğŸ˜„

```swift
let å‡½æ•°ç‚¹é˜µå¯†åº¦ = 64

let é¢‘ç‡1 = 4.0
let ç›¸ä½1 = 0.0
let å¹…åº¦1 = 1.0
let æ­£å¼¦å‡½æ•°1 = (0..<å‡½æ•°ç‚¹é˜µå¯†åº¦).map {
    å¹…åº¦1 * sin(2.0 * M_PI / Double(å‡½æ•°ç‚¹é˜µå¯†åº¦) * Double($0) * é¢‘ç‡1 + ç›¸ä½1)
}

let é¢‘ç‡2 = 1.0
let ç›¸ä½2 = M_PI / 2.0
let å¹…åº¦2 = 2.0
let æ­£å¼¦å‡½æ•°2 = (0..<å‡½æ•°ç‚¹é˜µå¯†åº¦).map {
    å¹…åº¦2 * sin(2.0 * M_PI / Double(å‡½æ•°ç‚¹é˜µå¯†åº¦) * Double($0) * é¢‘ç‡2 + ç›¸ä½2)
}

let é¢‘ç‡3 = 10.0
let ç›¸ä½3 = M_PI / 3.0
let å¹…åº¦3 = 4.0
let æ­£å¼¦å‡½æ•°3 = (0..<å‡½æ•°ç‚¹é˜µå¯†åº¦).map {
    å¹…åº¦3 * sin(2.0 * M_PI / Double(å‡½æ•°ç‚¹é˜µå¯†åº¦) * Double($0) * é¢‘ç‡3 + ç›¸ä½3)
}

let æ–°å‡½æ•°1 = add(æ­£å¼¦å‡½æ•°1, y: æ­£å¼¦å‡½æ•°2)
let æ–°å‡½æ•°2 = add(æ–°å‡½æ•°1, y: æ­£å¼¦å‡½æ•°3)

// Xcode åˆ†æ æŸ¥çœ‹å›¾å½¢æ’å¸ƒï¼Œå°¤å…¶æ˜¯æ–°å‡½æ•°çš„å›¾å½¢
æ–°å‡½æ•°1.forEach { XCPlaygroundPage.currentPage.captureValue($0, withIdentifier:"æ–°å‡½æ•°1") }
æ–°å‡½æ•°2.forEach { XCPlaygroundPage.currentPage.captureValue($0, withIdentifier:"æ–°å‡½æ•°2") }

æ­£å¼¦å‡½æ•°2.forEach { XCPlaygroundPage.currentPage.captureValue($0, withIdentifier:"æ­£å¼¦å‡½æ•°2") }

æ­£å¼¦å‡½æ•°1.forEach { XCPlaygroundPage.currentPage.captureValue($0, withIdentifier:"æ­£å¼¦å‡½æ•°1") }
```

#### å‚…é‡Œå¶å˜æ¢é€šä¿—ç¯‡[è®²è§£](https://www.douban.com/note/164400821)

```swift
// æŸ¥çœ‹å›¾åƒå‘ç°â€˜æ–°å‡½æ•°2â€™å·¦å³æœ‰ä¸‰å¯¹æ³¢å³°ï¼Œå¾—å‡ºå®ƒç”±ä¸‰ä¸ªæ­£å¼¦æ³¢ç»„æˆï¼ˆå¯å¯¹åº”å¾—å‡ºæŒ¯å¹…ã€é¢‘ç‡åŠç›¸ä½ï¼‰
let å¿«é€Ÿå‚…é‡Œå¶è½¬æ¢ = fft(æ–°å‡½æ•°2)
å¿«é€Ÿå‚…é‡Œå¶è½¬æ¢.forEach { XCPlaygroundPage.currentPage.captureValue($0, withIdentifier:"å¿«é€Ÿå‚…é‡Œå¶è½¬æ¢") }
```


### çŸ©é˜µè®¡ç®—
> å¾ˆå¤šå›¾åƒå¤„ç†æ˜¯æ ¹æ®çŸ©é˜µåšå¤„ç†çš„ï¼Œåƒç´ è¶Šå¤§ï¼Œå¤„ç†æ€§èƒ½è¦æ±‚è¶Šé«˜

```swift
// ç®€å•çŸ©é˜µç¤ºä¾‹

// â› 1  2 â      â› 3  2 â       â› 5  6 â
// â¢      âŸ  *   â¢      âŸ   =   â¢      âŸ
// â 3 -4 â       â 1  2 â        â 5 -2 â 

let A = Matrix([[1, 2], [3, -4]])
let B = Matrix([[3, 2], [1, 2]])
let C = A * B


// åˆ©ç”¨é€†çŸ©é˜µæ±‚è§£
// â› 1  1 â        â› 3 â           â› 2 â
// â¢      âŸ * CC = â¢   âŸ    CC =   â¢   âŸ
// â 1 -1 â         â 1 â            â 1 â 

let AA = Matrix([[1, 1], [1, -1]])
let BB = Matrix([[3], [1]])
let CC = inv(AA) * BB
```


### åº”ç”¨çš„åŠ é€Ÿåº“å‡½æ•°

```swift
import Accelerate

public func sum(x: [Double]) -> Double {
    var result: Double = 0.0
    vDSP_sveD(x, 1, &result, vDSP_Length(x.count))

    return result
}

public func max(x: [Double]) -> Double {
    var result: Double = 0.0
    vDSP_maxvD(x, 1, &result, vDSP_Length(x.count))

    return result
}

public func mean(x: [Double]) -> Double {
    var result: Double = 0.0
    vDSP_meanvD(x, 1, &result, vDSP_Length(x.count))

    return result
}

public func add(x: [Double], y: [Double]) -> [Double] {
    var results = [Double](y)
    cblas_daxpy(Int32(x.count), 1.0, x, 1, &results, 1)

    return results
}

public func fft(input: [Double]) -> [Double] {
    var real = [Double](input)
    var imaginary = [Double](count: input.count, repeatedValue: 0.0)
    var splitComplex = DSPDoubleSplitComplex(realp: &real, imagp: &imaginary)

    let length = vDSP_Length(floor(log2(Float(input.count))))
    let radix = FFTRadix(kFFTRadix2)
    let weights = vDSP_create_fftsetupD(length, radix)
    vDSP_fft_zipD(weights, &splitComplex, 1, length, FFTDirection(FFT_FORWARD))

    var magnitudes = [Double](count: input.count, repeatedValue: 0.0)
    vDSP_zvmagsD(&splitComplex, 1, &magnitudes, 1, vDSP_Length(input.count))

    var normalizedMagnitudes = [Double](count: input.count, repeatedValue: 0.0)
    vDSP_vsmulD(sqrt(magnitudes), 1, [2.0 / Double(input.count)], &normalizedMagnitudes, 1, vDSP_Length(input.count))

    vDSP_destroy_fftsetupD(weights)

    return normalizedMagnitudes
}
```
